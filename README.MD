# NSD SDK Gradle Plugin

Плагин поставляет ряд функций, упрощающих написание скриптов для NSD.
Все примеры будут указаны с использванием kotlin dls синтаксиса, использование в файлах gradle с groovy dls так же возможно, но синтаксис может чуть отличаться.  

# Подключение плагина

1. Разместите в вашем репозитории собранные пакеты с текущим плагином, а так же его зависимостями (можно в локальном)
2. Разместите в нужной вам инсталляции NSD [этот модуль](https://github.com/exeki/nsd.modules.sdk_controller)
3. В вашем проекте подключите в файл settings.gradle.kts репозиторий с текущим плагином (в примере указан локальный репозиторий):
```kotlin
rootProject.name = "random_scripts"
pluginManagement {
    repositories {
        mavenLocal()
        mavenCentral()
    }
}
```
4. Подключите плагин в файле build.gradle.kts вышего проекта
```kotlin
plugins {
    id("java")
    id("groovy")
    id("ru.kazantsev.nsd.sdk.gradle_plugin") version "1.0.0"
}
```

# Поддерживаемый функционал

## Глобальные переменные

Плагин по умолчанию подключает библиотеку [nsd.sdk.global_variables](https://github.com/exeki/nsd.sdk.global_variables), ее описание вы можете найти на ее страничке.

## Генерация фейковых классов NSD

Функционал позволяет работать в типизированном стиле с data объектами NSD, в тч позволяет использовать автодополнение кода.
Эту функцию рекомендуется использовать для написание больших объемов кода, либо используйте заранее настроенный проект для написания маленьких скриптов в заранее настроенной среде.

В рамках данного функционала происходит следующий процесс:
1. Запрос метаинформации всех добастных метаклассов из выбранной инсталляции NSD
2. Генерация java файлов по каждому забранному метаклассу. Каждый метакласс = один сгенерированный класс.
3. Генерация java проекта по сгенерированным файлам, его сборка и публикация в локальных репозиторий пользователя.
4. Подключение сгенерированного артефакта в текущий проект.

Для активации можно использовать два варианта:

### Первый вариант подключения

Этот вариант рекомендуется.

1. В соответствии с [описанием библиотеки nsd.basic_api_connector](https://github.com/exeki/nsd.basic_api_connector/blob/master/README.md) из раздела "Конфигурационный файл" создайте конфигурационный файл, указав в нем параметры инсталляции, для которой будут писаться скрипты. 
2. Вызовите метод **generate** в расширении **fakeClasses** файла **build.gradle.kts** вышего проекта, в качестве аргумета передайте ID указанной в конфигурационном файле инсталляции.
```kotlin
fakeClasses {
    generate("MY_SD")
}
```
3. Выполните пересборку gradle проекта

### Второй вариант подключения

Этот вариант НЕ рекомендуется.

1. Вызовите метод generate в расширении **fakeClasses** файла **build.gradle.kts** вышего проекта, в качестве аргуметов передайте:
- installationId: String - ID инсталляции 
- scheme: String - протокол (http или https)
- host: String - хост инсталляции
- accessKey: String - ключ доступа
- ignoreSLL: Boolean - игнорирование SSL при обращении к инсталляции
```kotlin
fakeClasses {
    generate(
        "MY_SD",
        "https",
        "my.nsd.ru",
        "g23g132-vf182-xcb2vh4-2dfg21-028vpk",
        true
    )
}
```
2. Выполните пересборку gradle проекта

### Использование

Для использования импортируете классы в нужный вам файл следующий пакет:
```groovy
import ru.naumen.core.server.script.spi.*
```
Все ранее сгенерированные классы содежатся в нем.
Теперь вы можете объявлять и кастовать нужные вам переменные классами, отличиными от Map, имеющими типизированные поля. 
IDE сама вам подскажет как называется тот или иной сгенерированный класс. 
Общие правила по преобразование кода метакласса в наименование сгенерированного класса такие:
1. Первая буква класса всегда заглавная
2. Знак доллара заменяется на нижнее подчеркивание
3. На конец названия класса добавляется преписка "_SDO" (что означает "script data object")
К примеру по метаклассу NSD "serviceCall$serviceCall" будет сгенерирован класс "ServiceCall_ServiceCall_SDO".
```groovy
import ru.naumen.core.server.script.spi.*
import static ru.kazantsev.nsd.sdk.global_variables.ApiPlaceholder.*

ServiceCall_ServiceCall_SDO object = utils.findFirst('serviceCall$serviceCall', [:]) as ServiceCall_ServiceCall_SDO
logger.info(object.number.toString())
logger.info(object.title)
logger.info(object.UUID)
```
Для теста попробуйте написать указанный ваше код своими руками, IDE подскажет вам все поля объекта.

### Обработка кода

Написанный код не получится вставить в NSD как есть, тк сгенерированных классов там нет, по этому вам требуется воспользоваться задачей **build_src** для того, что бы сгенерировать код без фейковых классов.
Данная задача обработает все файлы в папке **src/main** и на осовании них создаст файлы в папке **sdk/out** проекта. В созданных классах не будет упоминания фейковых классов, все они будут заменены на класс **ru.naumen.core.server.script.spi.IScriptDtObject**, который присутствует в classpath NSD.
Код из сгенерированных файлов можно размещать в NSD.

### Ручной вызов генерации фейковых классов

По умолчанию, если вы вызвали метод generate, при пересборке проекта расширение проверит есть ли сгенерированный и подключенный артефакт, описывающий вашу инсталляцию. 
Если его нет - плагин выполнит процесс генерации и подключения. При дальнейших открытиях проекта или его пересборке генерация происходить не будет, если зависимость уже есть в локальном репозитории. 
Но ваша инсталляция может развиваться: получать новые классы, типы и атрибуты, таким образом сгеенрированные фекйковые классы потеряют свою актуальность. Что бы это исправить выполните задачу **regenerate_all_fake_classes**, она выполнить запрос всей метаинформации из инсталляции и сгенерирует по ним зависимость.
Если вам нужно обновить в зависимости какой то определенный класс, то вы можете в расширении **fakeClasses** файла **build.gradle.kts** указать поле в **targetMeta** перечень метаклассов (Set), которые нужно обновить.
```kotlin
fakeClasses {
    generate("MY_SD")
    targetMeta = setOf("orderCall", "serviceCall")
}
```
После этого вызовите задачу **regenerate_target_fake_classes**, она затянет информацию только по указанным классам, что будет намного быстрее чем полное обновление.

## Выполние скриптов в NSD

Плагин может отправлять на выполнение в NSD ваши скрипты и возвращать вам результат. 
Для этого создайте в вашем проекте файл **src/main/console.groovy**. В нем вы можете написать свой скрипт в тч с использованием фейковых классов и плейсхолдер api (для этого в инсталляции нужен модуль **sdkPlaceholder** из проекта [nsd.sdk.global_variables](https://github.com/exeki/nsd.sdk.global_variables)).
Для отправки скрипта выполните задачу **send_script**.

Пример скрипта:
```groovy
import ru.naumen.core.server.script.spi.*
import static ru.kazantsev.nsd.sdk.global_variables.ApiPlaceholder.*

Root_SDO root = utils.get('root', [:])
return root.UUID
```
В консоли проекта вернет:
```
> Task :send_script
------------NSD SCRIPT RESULT------------
root$101
-----------------------------------------

BUILD SUCCESSFUL in 6s
1 actionable task: 1 executed
23:48:39: Execution finished 'send_script'.
```

Для удобства запуска своего скрипта в intellij ide вы можете добавить конфигурацию запуска, 
которая будет ссылаться на gradle задачу **send_script**, и запускать свой скрипт нажатием на кнопку Play в верхнем правом углу IDE.
Но помните, что выполняться будет всегда скрипт из файла **src/main/console.groovy**.




